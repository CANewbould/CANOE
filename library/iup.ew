--------------------------------------------------------------------------------
--	Library: iup.ew
--------------------------------------------------------------------------------
-- Notes:
--
-- 
--------------------------------------------------------------------------------
--/*
--= Library: iup.ew
-- Description: the base library to interface the IUP GUI with OE.
------
--[[[Version: 4.0.5.6
--Euphoria Versions: 4.0.5 upwards
--Author: C A Newbould
--Date: 2022.01.26
--Status: complete; operational
--Changes:]]]
--* changed dialog function names to lower-case
--* moved event-handling from //iup.e//
--* ##flush## defined
--
--==OE library: iup
--
-- This library hold all the widget-based functionality for running IUP GUI
-- appllications with user-defined top-level windows (##dialog##s).
--
-- To distinguish the "method" functions which are available to IUP widgets
-- from those in the system library (//iup.e//) these functions are named using
-- the camel-case convention.
--
-- This convention also applies to the event-handling routines.
--
-- All //creator// functions (##Constructor##s) use either the title-case
-- or the Pascal-case convention, in line with the documentated IUP function
-- names - less the leading //Iup//. Thus ##Vbox## calls ##IupVbox##, whereas
-- ##GridBox## calls ##IupGridBox##.
--
-- Utilise this support by adding the following statement to the calling
-- module:
-- <eucode>include iup.ew</eucode>
--*/
--------------------------------------------------------------------------------
--/*
--==Interface
--*/
--------------------------------------------------------------------------------
--
--=== Includes
--
--------------------------------------------------------------------------------
include iup.e -- for 'IUP'
include clib.e -- for 'Clib'
include crid.e -- for 'crid', 'Crid', 'fC', 'vfC'
include ints.e -- for 'ints'
include string.e -- for 'string'
--------------------------------------------------------------------------------
constant C_H = C_P, C_S = C_P
export enum CONTINUE = -4, CLOSE, DEFAULT, IGNORE
--------------------------------------------------------------------------------
constant M_CALL_BACK = 52
export function Icallback(string name, atom rid = routine_id(name)) -- ([c]) -> a
    return machine_func(M_CALL_BACK, {'+', rid})
end function
--------------------------------------------------------------------------------
--/*
--=== IUP widgets: types; constructors; methods
--*/
--------------------------------------------------------------------------------
export type Ihandle(atom h) -- t(a) -> h - a 'control' widget
    return h >= 0 -- allows for NULL
    end type
    export function getAttribute(Ihandle this, string attrib) -- f(h -> [c]) -> [c]
        crid GA = Crid("+IupGetAttribute", IUP, {C_P, C_S}, C_S)
        return peek_string(c_func(GA, {this, s2c(attrib)}))
    end function
    export function setAttribute(Ihandle widget, string attrib, string val) -- f(h -> [c] -> [c]) -> v
        crid SA = Crid("+IupSetAttribute", IUP, {C_H, C_S, C_S})
        return vfC(SA, {widget, s2c(attrib), s2c(val)})
    end function
    export function setCallback(Ihandle widget, string action, atom fn) -- f(h -> [c] -> a) -> a
        crid SC = Crid("+IupSetCallback", IUP, {C_H, C_S, C_I}, C_I)
        return fC(SC, {widget, s2c(action), fn})
    end function
    --void IupSetFloat (Ihandle* ih, const char* name, float value);
    export function setFloat(Ihandle widget, string attrib, atom val) -- f(h -> [c] -> a) -> v
        crid SF = Crid("+IupSetFloat", IUP, {C_H, C_S, C_I})
        return vfC(SF, {widget, s2c(attrib), val})
    end function
    export function setInt(Ihandle widget, string attrib, integer val) -- f(h -> [c] -> i) -> v
        crid SI = Crid("+IupSetInt", IUP, {C_H, C_S, C_I})
        return vfC(SI, {widget, s2c(attrib), val})
    end function
    export function Button(string title, string action = "") -- f([c] -> [c]) -> h
        crid B = Crid("+IupButton", IUP, {C_S, C_S}, C_H)
        return fC(B, {s2c(title), s2c(action)})
    end function
    export function Canvas(string action = "") -- f([c]) -> h
        crid C = Crid("+IupCanvas", IUP, {C_S}, C_H)
        return fC(C, {s2c(action)})
    end function
    export function Fill() -- f() -> h
        crid F = Crid("+IupFill", IUP, {}, C_H)
        return fC(F, {})
    end function
    export function Gauge() -- f() -> h
        crid G = Crid("+IupGauge", IUP, {}, C_H)
        return fC(G, {})
    end function
    export function Label(string title) -- f([c]) -> h
        crid L = Crid("+IupLabel", IUP, {C_S}, C_H)
        return fC(L, {s2c(title)})
    end function
    export function New(Ihandle i, string s) -- f(h -> [c]) --> h
        crid SAS = Crid("+IupSetAttributes", IUP, {C_H, C_S}, C_H)
        return fC(SAS, {i, s2c(s)})
    end function
    export function Space() -- f() -> h
        crid S = Crid("+IupSpace", IUP, {}, C_H)
        return fC(S, {})
    end function
    export function Text(string action = "") -- f([c]) -> h
        crid T = Crid("+IupText", IUP, {C_S}, C_H)
        return fC(T, {s2c(action)})
    end function
    export function Toggle(string title, string action = "") -- f([c] -> [c]) -> h
        crid T = Crid("+IupToggle", IUP, {C_S, C_S}, C_H)
        return fC(T, {s2c(title), s2c(action)})
    end function
--------------------------------------------------------------------------------
export type container(atom c)
    return Ihandle(c)
    end type
    export function Frame(Ihandle child) -- f(h) -> h
        crid F = Crid("+IupFrame", IUP, {C_H}, C_H)
        return fC(F, {child})
    end function
    export function Hbox(ints children) -- f([h]) -> h
        crid HB = Crid("+IupHbox", IUP, repeat(C_H, length(children)+1), C_H)
        return fC(HB, children & NULL)
        end function
    export function Radio(container c = NULL) -- f(h) -> h
        crid R = Crid("+IupRadio", IUP, {C_H}, C_H)
        return fC(R, {c})
    end function
    export function Vbox(ints children) -- f([h]) -> h
        crid VB = Crid("+IupVbox", IUP, repeat(C_H, length(children)+1), C_H)
        return fC(VB, children & NULL)
        end function
--------------------------------------------------------------------------------
export type dialog(atom d) -- t(a -> t(h)) -> d
    return Ihandle(d)
    end type
    export function Dialog(Ihandle child = NULL) -- f(h) -> d
        crid D = Crid("+IupDialog", IUP, {C_H}, C_H)
        return fC(D, {child})
        end function
    export function destroy(dialog d) -- f(d) -> i
        crid D = Crid("+IupDestroy", IUP, {C_H}, C_I)
        return fC(D, {d})
        end function
    export function hide(dialog d) -- f(d) -> i
        crid H = Crid("+IupHide", IUP, {C_H}, C_I)
        return fC(H, {d})
        end function
    export function show(dialog d, ints pos = {}) -- f(d -> [i]) -> i
        if length(pos) then
            crid SXY = Crid("+IupShowXY", IUP, {C_H, C_I, C_I}, C_I)
            return fC(SXY, {d} & pos)
        else
            crid S = Crid("+IupShow", IUP, {C_H}, C_I)
            return fC(S, {d})
        end if
        end function
    export function error(dialog d = NULL, string message) -- f(d -> [c]) -> v
        crid E = Crid("+IupMessageError", IUP, {C_H, C_S})
        return vfC(E, {d, s2c(message)})
    end function
    export function alarm(dialog d = NULL, string message, string title, string buttons = "OK") -- f(d -> [c] -> [c] -> [c]) -> i
        crid A = Crid("+IupMessageAlarm", IUP, {C_H, C_S, C_S, C_S}, C_I)
        return fC(A, {d, s2c(title), s2c(message), s2c(buttons)})
    end function
--------------------------------------------------------------------------------
--/*
--=== IUP event-handling
--*/
--------------------------------------------------------------------------------
export function exitLoop() -- f() -> v
    crid EL = Crid("+IupExitLoop", IUP)
    return vfC(EL)
    end function
--------------------------------------------------------------------------------
export function flush() -- f() -> v
    crid EL = Crid("+IupFlush", IUP)
    return vfC(EL)
    end function
--------------------------------------------------------------------------------
export function mainLoop() -- f() -> v
    crid ML = Crid("+IupMainLoop", IUP)
    return vfC(ML)
    end function
--------------------------------------------------------------------------------
-- Previous versions
--------------------------------------------------------------------------------
--[[[Version: 4.0.5.5
--Euphoria Versions: 4.0.5 upwards
--Author: C A Newbould
--Date: 2022.01.25
--Status: complete; operational
--Changes:]]]
--* ##Frame## defined
--------------------------------------------------------------------------------
--[[[Version: 4.0.5.4
--Euphoria Versions: 4.0.5 upwards
--Author: C A Newbould
--Date: 2022.01.23
--Status: complete; operational
--Changes:]]]
--* ##Destroy## defined
--------------------------------------------------------------------------------
--[[[Version: 4.0.5.3
--Euphoria Versions: 4.0.5 upwards
--Author: C A Newbould
--Date: 2022.01.22
--Status: complete; operational
--Changes:]]]
--* ##Fill## defined
--* ##SetFloat## defined
--* ##SetInt## defined
--* ##Space## defined
--------------------------------------------------------------------------------
--[[[Version: 4.0.5.2
--Euphoria Versions: 4.0.5 upwards
--Author: C A Newbould
--Date: 2022.01.03
--Status: complete; operational
--Changes:]]]
--* ##Alarm## defined
--* ##Gauge## defined
--* ##Canvas## defined
--------------------------------------------------------------------------------
--[[[Version: 4.0.5.1
--Euphoria Versions: 4.0.5 upwards
--Author: C A Newbould
--Date: 2022.01.02
--Status: complete; operational
--Changes:]]]
--* ##GetAttribute## defined
--* ##New## defined
--* ##Text## defined
--* ##Radio## defined
--------------------------------------------------------------------------------
--[[[Version: 4.0.5.0
--Euphoria Versions: 4.0.5 upwards
--Author: C A Newbould
--Date: 2022.01.01
--Status: complete; operational
--Changes:]]]
--* created
--------------------------------------------------------------------------------
